# 链路追踪,限流,熔断

1. 启动链路追踪类

```solidity
func Init(serviceName string) (func(context.Context) error, error) {
	exp, err := stdouttrace.New(
		stdouttrace.WithWriter(os.Stdout),
		stdouttrace.WithPrettyPrint(),
	)
	if err != nil {
		return nil, err
	}

	tp := sdktrace.NewTracerProvider(
		sdktrace.WithBatcher(exp),
		sdktrace.WithResource(resource.NewWithAttributes(
			semconv.SchemaURL,
			semconv.ServiceName(serviceName),
		)),
	)

	otel.SetTracerProvider(tp)

	// 关键：让 client/server 通过 metadata 传播同一条 trace
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
		propagation.TraceContext{},
		propagation.Baggage{},
	))

	return tp.Shutdown, nil
}

```

1. 生成提取traceId

```solidity
func TraceId(ctx context.Context) string {
	tc := trace.SpanContextFromContext(ctx)

	if !tc.IsValid() {
		return ""
	}
	return tc.TraceID().String()
}

func SpanID(ctx context.Context) string {
	sc := trace.SpanContextFromContext(ctx)
	if !sc.IsValid() {
		return ""
	}
	return sc.SpanID().String()
}

```

1. Zap初始化注入

```solidity
func New() (*zap.Logger, error) {
	cfg := zap.NewProductionConfig()
	cfg.EncoderConfig.TimeKey = "ts"
	cfg.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
	return cfg.Build()
}

// FromContext 返回带 trace_id/span_id 的 logger（如果 ctx 里有的话）
func FromContext(ctx context.Context, base *zap.Logger) *zap.Logger {
	tid := traceutil.TraceID(ctx)
	if tid == "" {
		return base
	}
	sid := traceutil.SpanID(ctx)
	return base.With(
		zap.String("trace_id", tid),
		zap.String("span_id", sid),
	)
}

```

1. 统一grpc拦截器

```solidity
func UnaryZapLogger(base *zap.Logger) grpc.UnaryServerInterceptor {
	return func(
		ctx context.Context,
		req any,
		info *grpc.UnaryServerInfo,
		handler grpc.UnaryHandler,
	) (any, error) {
		start := time.Now()

		// 注意：otelgrpc 的 StatsHandler 会创建/提取 span。
		// 这里从 ctx 里拿 trace_id/span_id（若存在）
		lg := logx.FromContext(ctx, base).With(
			zap.String("grpc.method", info.FullMethod),
		)

		lg.Info("grpc.request.start")

		resp, err := handler(ctx, req)

		cost := time.Since(start)
		st, _ := status.FromError(err)
		code := st.Code()
		if err == nil {
			code = codes.OK
		}

		fields := []zap.Field{
			zap.String("grpc.code", code.String()),
			zap.Int64("cost_ms", cost.Milliseconds()),
		}

		if err != nil {
			// st.Message() 给人看，err 给日志内部排查用
			fields = append(fields,
				zap.String("err_msg", st.Message()),
				zap.Error(err),
			)
			lg.Warn("grpc.request.end", fields...)
			return resp, err
		}

		lg.Info("grpc.request.end", fields...)
		return resp, nil
	}
}

```

1. 在拦截器里面初始化

```solidity
s := grpc.NewServer(
		// 1) 追踪（生成 server span / 提取 trace context）
		grpc.StatsHandler(otelgrpc.NewServerHandler()),

		// 2) 日志（自动带 trace_id）
		grpc.UnaryInterceptor(interceptors.UnaryZapLogger(lg)),
	)

```

1. client初始化

```solidity
conn, err := grpc.Dial(
		"127.0.0.1:50051",
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithStatsHandler(otelgrpc.NewClientHandler()),
	)

```

1. 在gin中创建OTel 作为初始化

```solidity
func TraceMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// 以 HTTP path 作为 span 名
		ctx, span := otel.Tracer("gateway/http").Start(c.Request.Context(), c.FullPath())
		defer span.End()

		// 把新 ctx 写回 request，后面你拿它就有 trace_id 了
		c.Request = c.Request.WithContext(ctx)

		c.Next()
	}
}

```

限流熔断

```solidity
	func RateLimitUnaryInterceptor(l *rate.Limiter) grpc.UnaryServerInterceptor {
	return func(
		ctx context.Context,
		req any,
		info *grpc.UnaryServerInfo,
		handler grpc.UnaryHandler,
	) (any, error) {
		// Allow() 是“立即判断”，不等待；适合网关/高吞吐
		if !l.Allow() {
			return nil, status.Error(codes.ResourceExhausted, "rate limited")
		}
		return handler(ctx, req)
	}
}

// 每秒 100 个令牌，突发 200（你可以改小看效果）
limiter := rate.NewLimiter(100, 200)

grpcServer := grpc.NewServer(
	grpc.UnaryInterceptor(server.RateLimitUnaryInterceptor(limiter)),
)

```

> 限流都是在服务端 限流需要抛出codes.ResourceExhausted 让客户端去捕获这个错误,做出metric指标
> 

```solidity
// 你可以用 errors.Is(err, gobreaker.ErrOpenState) 来识别熔断打开
var ErrCircuitOpen = gobreaker.ErrOpenState

func NewBreaker(name string) *gobreaker.CircuitBreaker {
	st := gobreaker.Settings{
		Name:        name,
		MaxRequests: 5,               // 半开时允许通过的请求数
		Interval:    10 * time.Second, // 统计窗口
		Timeout:     3 * time.Second,  // Open 状态持续多久后进入 Half-Open
		ReadyToTrip: func(c gobreaker.Counts) bool {
			// 触发条件：在窗口内请求 >= 20 且失败率 >= 50%
			if c.Requests < 20 {
				return false
			}
			failRate := float64(c.TotalFailures) / float64(c.Requests)
			return failRate >= 0.5
		},
		// 你也可以在 OnStateChange 里打日志/指标
	}
	return gobreaker.NewCircuitBreaker(st)
}

func CircuitBreakerUnaryInterceptor(cb *gobreaker.CircuitBreaker) grpc.UnaryClientInterceptor {
	return func(
		ctx context.Context,
		method string,
		req, reply any,
		cc *grpc.ClientConn,
		invoker grpc.UnaryInvoker,
		opts ...grpc.CallOption,
	) error {
		_, err := cb.Execute(func() (any, error) {
			return nil, invoker(ctx, method, req, reply, cc, opts...)
		})
		return err
	}
}

// 可选：把哪些 gRPC code 算“失败”（影响熔断）
func IsFailure(err error) bool {
	if err == nil {
		return false
	}
	st, ok := status.FromError(err)
	if !ok {
		return true
	}
	switch st.Code() {
	case codes.Unavailable, codes.DeadlineExceeded, codes.ResourceExhausted:
		return true // 通常算下游不可用/拥塞：应该触发熔断
	default:
		return false // InvalidArgument/NotFound 这类通常不算“下游不健康”
	}
}

// 如果你想更严格：把 Execute 包一层，只有 IsFailure(err) 才计入失败
func CircuitBreakerUnaryInterceptorWithFailureClassify(cb *gobreaker.CircuitBreaker) grpc.UnaryClientInterceptor {
	return func(
		ctx context.Context,
		method string,
		req, reply any,
		cc *grpc.ClientConn,
		invoker grpc.UnaryInvoker,
		opts ...grpc.CallOption,
	) error {
		_, err := cb.Execute(func() (any, error) {
			e := invoker(ctx, method, req, reply, cc, opts...)
			if IsFailure(e) {
				return nil, e
			}
			// 不算失败时，返回 nil 表示成功（避免把业务错误算进熔断）
			return nil, nil
		})
		// 注意：上面“业务错误不算失败”会吞掉业务错误；一般用于只保护可用性调用。
		// 生产更常见做法：不吞业务错误，而是自定义计数。这里保持最小 demo。
		return err
	}
}

func IsOpenErr(err error) bool {
	return errors.Is(err, gobreaker.ErrOpenState)
}

```

> 熔断都在客户端
> 

监控和报警 后面在写入